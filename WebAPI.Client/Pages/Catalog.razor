@page "/catalog"
@inject HttpClient Http

@using System.Text.Json
@using WebAPI.Shared;

<!-- Main Container -->
<div class="catalog-page-container">
    <h1>Catalog</h1>
    <p>Browse and discover items available for checkout from the library. Search for useful resources beyond books!</p>

    <!-- Search Bar -->
    <div class="search-container">
        <input @bind="searchQuery" placeholder="Search items..." class="search-bar" />
        <button @onclick="SearchItems" class="search-button">Search</button>
    </div>

    <!-- Results Section (Table) -->
    @if (items != null && items.Any())
    {
        <table class="catalog-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Available</th>
                    <th>Image</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var item in items.Take(10))
                {
                    <tr>
                        <td>@item.ID</td>
                        <td>@item.Name</td>
                        <td>@item.Description</td>
                        <td>@item.AmountAvailable</td>
                        <td><img src="@item.ImageURL" alt="@item.Name" class="item-image" /></td>
                    </tr>
                }
            </tbody>
        </table>
    }
    else if (items != null && !items.Any())
    {
        <p>No results found.</p>
    }
</div>

@code {
    private string searchQuery = string.Empty;
    private List<Item> items = new List<Item>();
    private bool isLoading;
    private string? errorMessage;

    private async Task SearchItems()
    {
        try
        {
            isLoading = true;
            var encodedQuery = Uri.EscapeDataString(searchQuery);

            var response = await Http.GetAsync($"api/items/search?query={encodedQuery}");
            if (response.IsSuccessStatusCode)
            {
                // Read the content only once
                var jsonString = await response.Content.ReadAsStringAsync();

                var options = new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true,
                        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                    };

                try
                {
                    // Try parsing as a single item first
                    var singleItem = JsonSerializer.Deserialize<Item>(jsonString, options);
                    if (singleItem != null)
                    {
                        items = new List<Item> { singleItem };
                    }
                }
                catch
                {
                    // If that fails, try parsing as a list
                    items = JsonSerializer.Deserialize<List<Item>>(jsonString, options) ?? new List<Item>();
                }
            }
            else
            {
                errorMessage = $"Server returned status code: {response.StatusCode}";
                items = new List<Item>();
            }
        }
        catch (HttpRequestException ex)
        {
            errorMessage = "Unable to connect to the server. Please try again.";
            Console.WriteLine($"Network error: {ex.Message}");
            items = new List<Item>();
        }
        catch (JsonException ex)
        {
            errorMessage = "Error processing server response.";
            Console.WriteLine($"JSON parsing error: {ex.Message}");
            items = new List<Item>();
        }
        catch (Exception ex)
        {
            errorMessage = "An unexpected error occurred.";
            Console.WriteLine($"Unexpected error: {ex.Message}");
            items = new List<Item>();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }
}